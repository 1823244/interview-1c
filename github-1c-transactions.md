https://infostart.ru/1c/articles/1733411/

ЕНС. КОПИЯ ЕСТЬ В EVERNOTE, блокнот 1С

 Список правил при работе с транзакциями из BSL Language Server и SonarQube 1C (BSL) Plugin. 
 Переработка и осмысление материала.

Описание диагностик из проектов BSL Language Server и SonarQube 1C (BSL) Plugin 
https://1c-syntax.github.io/bsl-language-server/diagnostics/
https://docs.checkbsl.org/checks/%D0%9E%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%9F%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B8%D0%9A%D0%BE%D0%B4%D0%B0/

https://habr.com/ru/post/419715/
 
Общепринятый паттерн

Описан в ИТС

НачатьТранзакцию();
Попытка
    ... // чтение или запись данных
    ЗафиксироватьТранзакцию();
Исключение
    ОтменитьТранзакцию();
    ... // дополнительные действия по обработке исключения
КонецПопытки;

 
Метод "НачатьТранзакцию" должен располагаться непосредственно перед оператором "Попытка"

Источник
https://docs.checkbsl.org/checks/overall/BeginTransactionInTryBlock/

Описание диагностики 

Метод НачатьТранзакцию должен быть за пределами блока Попытка-Исключение непосредственно перед оператором Попытка.

Начало транзакции и ее фиксация (отмена) должны происходить в контексте одного метода.

Код, который начинает транзакцию, обязан завершить или откатить ее. В случаях когда метод НачатьТранзакцию() находится внутри блока Попытка-Исключение есть риск нарушения парности вызовов НачатьТранзакцию()-ЗафиксироватьТранзакцию(), что может привести к трудно анализируемым ошибкам времени выполнения типа "В этой транзакции уже происходили ошибки."

Примеры

Неправильно:

Процедура Пример2()
    НачатьТранзакцию(); // <-- Ошибка: код перед попыткой
    Метод();
    Попытка
        Метод2();
    Исключение
        ОтменитьТранзакцию();
        Возврат;
    КонецПопытки;
    ЗафиксироватьТранзакцию();
КонецПроцедуры

Процедура Пример3()
    Попытка
        НачатьТранзакцию(); // <-- Ошибка: в попытке
        Метод();
    Исключение
        Если ТранзакцияАктивна() Тогда
            ЗафиксироватьТранзакцию();
        Иначе
            ОтменитьТранзакцию();
        КонецЕсли;
        Возврат;
    КонецПопытки;
КонецПроцедуры

 
Метод "ЗафиксироватьТранзакцию" должен идти последним в блоке "Попытка"

Источник
https://1c-syntax.github.io/bsl-language-server/diagnostics/CommitTransactionOutsideTryCatch/
Описание диагностики

Метод 'ЗафиксироватьТранзакцию' должен идти последним в блоке 'Попытка' перед оператором 'Исключение', чтобы гарантировать, что после ЗафиксироватьТранзакцию не возникнет исключение.

Примеры

Неправильно:

Процедура Пример2()
    НачатьТранзакцию();
    Попытка
        Метод();
    Исключение
        ОтменитьТранзакцию();
        Возврат;
    КонецПопытки;
    ЗафиксироватьТранзакцию(); // <-- Ошибка: вне попытки
КонецПроцедуры

Процедура Пример3()
    НачатьТранзакцию();
    Попытка
        Метод();
    Исключение
        Если ТранзакцияАктивна() Тогда
            ЗафиксироватьТранзакцию(); // <-- Ошибка: в исключении
        Иначе
            ОтменитьТранзакцию();
        КонецЕсли;
        Возврат;
    КонецПопытки;
КонецПроцедуры

 
Метод "ОтменитьТранзакцию" должен идти первым в блоке "Исключение"

Источник
https://1c-syntax.github.io/bsl-language-server/diagnostics/WrongUseOfRollbackTransactionMethod/

Описание диагностики

В блоке Исключение нужно сначала вызвать метод ОтменитьТранзакцию, а затем выполнять другие действия, если они требуются.

Такое правило необходимо, чтобы убрать потенциальную возможность выброса исключения в блоке "Исключение", что может привести к тому, что метод "ОтменитьТранзакцию" не будет вызван.
Примеры

Неправильно:

Процедура ЗаписатьЭлемент()
    НачатьТранзакцию();
    Попытка
        Метод();
        ЗафиксироватьТранзакцию();
    Исключение
        Метод2(); // <-- Ошибка: код перед отменой
        ОтменитьТранзакцию();
    КонецИсключения;
КонецПроцедуры

 
Необоснованное использование метода ТранзакцияАктивна()

При жестком соблюдении правил работы с транзакциями использование метода ТранзакцияАктивна() в блоке Исключение становится лишним.

Требует обоснования:

НачатьТранзакцию();
Попытка
    ДелаемЧтоТо();
    ЗафиксироватьТранзакцию();
Исключение
    Если ТранзакцияАктивна() Тогда
        ОтменитьТранзакцию();
    КонецЕсли;
    ЗаписьЖурналаРегистрации();
КонецПопытки;

Использование данного паттерна нарушает инкапсуляцию и приводит к "размазыванию" логики управления транзакциями. 

    На нашем уровне абстракции мы обязаны заботиться только о нашей транзакции. 
	Все прочие должны быть нам неинтересны. 
	Они чужие, мы не должны нести за них ответственность. 
	Именно НЕ ДОЛЖНЫ. Нельзя предпринимать попыток выяснения реального уровня счетчика транзакций. (с) Вы не умеете работать с транзакциями

Alexey Lab Sosnoviy
я не пользую ТранзакцияАктивна т.к. не понял зачем оно =) Я транзакцияю начал, я же отменил, а вские там маскировки того что внутри имхо зло

Nikita Fedkin
Использование этого метода на любом уровне означает, что на уровне ниже есть ошибка в обработке транзакций. Ошибку надо исправить, и метод будет не нужен :)

Вот если код нельзя исправить (например, внешнее решение без исходников или запрет на изменение даже расширениями), короче, если не доверяешь коду и знаешь, что он может стрельнуть, при этом после верхнеуровневой транзакции есть какой-то код, который тоже работает с бд, то да, тогда в верхнем уровне можно это вставить. Но лучше втащить автору кода ниже, это продуктивнее

Андрей Овсянкин
В той статье есть еще комментарии. И там я согласился с доводами, что есть более хорошее решение "общего вида". Мое решение тоже хорошее, но для условий, когда "вокруг говнокод и никому верить нельзя". Для вменяемой кодовой базы и с вменяемой командой - лучше брать паттерн с ИТС

Артур Аюханов
в модульных тестах активно юзаю этот метод перед отменой транзакции и рекомендую всем его юзать в серверных модульных тестах
т.к. не всегда можно гарантировать наличие транзакции из-за ошибок в коде и т.п.

Сергей Старых
Так делать не всегда неправильно. Более правильной я считаю безусловную отмену транзакции в исключении.

Олег Тымко
Я считаю, что проверка «ТранкзакцияАктивна» перед отменой - это заметание под ковер. Но иногда это нужно делать, как, например, с безумными обменами через КД, когда там в любой момент могут попорить активную транкзакцию. 

Если считаем что это необходимо - просто игнорим срабатывание правила

Примечание: с помощью метода ТранзакцияАктивна() нельзя узнать что транзакция сломана

 
При обработке исключений необходимо использовать метод ЗаписьЖурналаРегистрации()

Источник
https://1c-syntax.github.io/bsl-language-server/diagnostics/MissingCodeTryCatchEx/

Недопустимо перехватывать любые исключения, бесследно для системного администратора.

Неправильно

Попытка 
    // код, приводящий к вызову исключения
    ....
Исключение // перехват любых исключений
КонецПопытки;

Как правило, подобная конструкция скрывает реальную проблему, которую впоследствии невозможно диагностировать.

Правильно


Попытка 
    // код, приводящий к вызову исключения
    ....
Исключение
    // Пояснение причин перехвата всех исключений "незаметно" от пользователя.
    // ....
    // И запись события в журнал регистрации для системного администратора.
    ЗаписьЖурналаРегистрации(НСтр("ru = 'Выполнение операции'"),
       УровеньЖурналаРегистрации.Ошибка,,,
       ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
КонецПопытки;

Необходимо обязательно указывать 1, 2 и 5 параметр метода ЗаписьЖурналаРегистрации()

Источник
https://1c-syntax.github.io/bsl-language-server/diagnostics/UsageWriteLogEvent/

Нельзя пропускать 1й параметр. Нельзя указывать его и переменной строкой - это вызывает раздувание словаря ЖР (1Cv8.lgf) и, как следствие, зависание при его открытии.

Нельзя пропускать 2й параметр - Уровень журнала регистрации. Если его не указать, по умолчанию 1С применит уровень ошибки Информация, и данная запись может потеряться в потоке записей.

Нельзя пропускать и 5й параметр - комментарий к событию записи в журнал регистрации. При обработке исключений обязательно нужно выполнять запись в журнал регистрации с полным представлением ошибки.

Неправильно:

ЗаписьЖурналаРегистрации("Событие");// ошибка
ЗаписьЖурналаРегистрации("Событие" + Ссылка); // ошибка
ЗаписьЖурналаРегистрации("Событие", УровеньЖурналаРегистрации.Ошибка);// ошибка
ЗаписьЖурналаРегистрации("Событие", , , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));//ошибка

ЗаписьЖурналаРегистрации("Событие", УровеньЖурналаРегистрации.Ошибка, , , ОписаниеОшибки());//ошибка

ОписаниеОшибки() и КраткоеПредставлениеОшибки() не содержат текста строки, вызвавшей ошибку. Код может измениться к моменту анализа ошибки, и придется дополнительно исследовать, где же именно возникла ошибка.

 
Обращение к внешним ресурсам внутри транзакции вызывает проблемы производительности

Источник
https://github.com/1c-syntax/bsl-language-server/issues/1538

Крайне не рекомендуется помещать вызов внешних ресурсов\сервисов внутри транзакции, явной или неявной.
Подобные вызовы могут значительно увеличить время выполнения транзакций, а это может повлечь за собой различные проблемы с производительностью, блокировкой, параллельной работой пользователей.

В качестве внешних ресурсов следует рассматривать любые ресурсы, которыми напрямую не управляет сервер 1С.

    Файловая система
    http-, web-сервисы
    ftp
    com-вызовы в Windows
    обращения к сторонним СУБД
    и т.п.

Нужно учитывать

    как явные транзакции - НачатьТранзакцию
    так и неявные - внутри системных событий 1С
        например, код внутри события ПередЗаписью, ОбработкаПроведения и т.п.

Неправильно:

// Подписка ПриЗаписи - транзакция открыта
Процедура усВыгрузитьДокументПриЗаписи(Источник, Отказ) Экспорт

    // ...
    // Подключение к внешнему веб-сервису, при недоступности которого транзакция зависнет
    WSПрокси = Новый WSПрокси(WSОпределение, URIПространстваИмен, ИмяСервиса);	// без таймаута

    Файл.Записать(); // обращение к файловой системе

    Почта.Отправить(); // обращение к SMTP серверу

КонецПроцедуры

Правильно:

Вынести обращение к внешним ресурсам за пределы транзакции

 

Внутри транзакции недопустимо подавлять ошибки, вызывающие событие SDBL Func='setRollbackOnly'

ИТС: Ошибки базы данных и транзакции
https://its.1c.ru/db/metod8dev/content/2313/hdoc

Если ошибка базы данных произошла в процессе выполнения транзакции, то транзакция уже не может быть продолжена или зафиксирована. Единственная операция с базой данных, которую можно произвести в такой ситуации - это отмена транзакции.

Неправильно:

НачатьТранзакцию();
Попытка
    // ...
    Попытка
        Объект.Записать(); // ПриЗаписи Отказ = Истина - вызовет setRollbackOnly
    Исключение
         ЗаписьЖурналаРегистрации();
    КонецПопытки;
    ЗафискироватьТранзакцию(); // <-- Ошибка: транзакция завершится откатом, исключение выдано не будет
Исключение
    ОтменитьТранзакцию();
    // ...
КонецПопытки;

Метод ЗафиксироватьТранзакцию() при глубине = 1 не всегда фиксирует фактическую транзакцию, а закрывает ее путем отката если она сломана и путем фиксации если она не сломана.

Без проброса исключения либо команда "ЗафискироватьТранзакцию();" отменит транзакцию, либо следующее обращение к базе данных вызывает ошибку «В данной транзакции уже происходили ошибки». 

Неправильно:

Процедура ОбработкаПроведения()
    Попытка
        ...запись в базу с ошибкой
    Исключение
        //по стандарту должно быть исключение, т.к. есть внешняя транзакция 
        //но его не было
        //ВызватьИсключение; 
    КонецПопытки;
    // <-- Ошибка: "В данной транзакции уже происходили ошибки!"
КонецПроцедуры

В каких случаях подавление ошибок делает транзакцию "сломанной":

    Вызов метода ОтменитьТранзакцию() внутри "вложенной" транзакции
    Ошибка или отказ в методе Записать()
    Выполнение некорректного запроса, вида "ВЫБРАТЬ 1/0"

Событие в технологическом журнале:
20:43.385010-1,SDBL,5,process=1CV8,OSThread=12256,Usr=DefUser,DBMS=DBV8DBEng, DataBase=InfoBase75, Trans=1, Func=setRollbackOnly - установка флага наличия в транзакции ошибки (ее можно только откатить)

Примеры 

Отмена "вложенной" явной транзакции:

НачатьТранзакцию();
НачатьТранзакцию();
ОтменитьТранзакцию();
ЗафиксироватьТранзакцию();

20:43.385006-0,SDBL,5,process=1CV8,OSThread=12256,Usr=DefUser, DBMS=DBV8DBEng, DataBase=InfoBase75, Trans=1, Func=BeginTransaction, Context='ВнешняяОбработка.ВнешняяОбработка2.Форма.Форма.Форма : 3 : НачатьТранзакцию();'
20:43.385010-1,SDBL,5,process=1CV8,OSThread=12256,Usr=DefUser, DBMS=DBV8DBEng, DataBase=InfoBase75, Trans=1, Func=setRollbackOnly, Context='ВнешняяОбработка.ВнешняяОбработка2.Форма.Форма.Форма : 5 : ОтменитьТранзакцию();'
20:43.385013-8,SDBL,4,process=1CV8,OSThread=12256,Usr=DefUser, DBMS=DBV8DBEng, DataBase=InfoBase75, Trans=0,Func=Transaction, Func=RollbackTransaction, Context='ВнешняяОбработка.ВнешняяОбработка2.Форма.Форма.Форма : 6 : ЗафиксироватьТранзакцию();'
20:43.400000-14996,SDBL,3,process=1CV8,OSThread=12256,Usr=DefUser, DBMS=DBV8DBEng, DataBase=InfoBase75, Trans=0, Func=HoldConnection, Context='ВнешняяОбработка.ВнешняяОбработка2.Форма.Форма.Форма : 6 : ЗафиксироватьТранзакцию();'

Отмена "вложенной" неявной транзакции:

Процедура ПередЗаписью(Отказ, РежимЗаписи, РежимПроведения)
    // пример ошибки "В данной транзакции уже происходили ошибки" в неявной транзакции
    Попытка
        ДокументОбъект = Документы.Документ1.СоздатьДокумент();
        ДокументОбъект.ВызыватьОтказ = Истина;
        ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение); // ломаем транзакцию
    Исключение
    КонецПопытки;
КонецПроцедуры

15:46.832029-_0,SDBL,5,process=1cv8,OSThread=16468,Usr=DefUser, DBMS=DBV8DBEng, DataBase=InfoBase75, Trans=1, Func=BeginTransaction
15:46.848001_1,SDBL,5,process=1cv8,OSThread=16468,Usr=DefUser, DBMS=DBV8DBEng, DataBase=InfoBase75, Trans=1, Func=setRollbackOnly, Context='Документ.Документ1.МодульОбъекта : 14 : ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение); // ломаем транзакцию'
15:46.910004_0,EXCP,6,process=1cv8,OSThread=16468,Usr=DefUser, DBMS=DBV8DBEng, DataBase=InfoBase75, Exception=DataBaseException, Descr=В данной транзакции уже происходили ошибки!
15:46.910008_77980,SDBL,4,process=1cv8,OSThread=16468,Usr=DefUser, DBMS=DBV8DBEng, DataBase=InfoBase75, Trans=0, Func=Transaction, Func=RollbackTransaction

Формат записей ТЖ:

https:// /articles/технологический-журнал-анализ-логов/

Настройка logcfg.xml:

<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://v8.1c.ru/v8/tech-log">
    <dump create="false" type="0" prntscrn="false"/>
    <log history="2" location="D:\Database\Log">
        <property name="all"/>
        <event>
            <eq property="name" value="SDBL"/>
            <eq property="func" value="setRollbackOnly"/>
        </event>
    </log>
</config>

 

Ещё один вариант этого правила:
При использовании вложенных транзакций в конце блока Исключение рекомендуется добавить оператор ВызватьИсключение

ИТС: Транзакции: правила использования
https://its.1c.ru/db/v8std/content/783/hdoc

Как известно, «1С:Предприятие 8» не поддерживает вложенных транзакций. 

    ИТС: Вложенность транзакций
	https://its.1c.ru/db/metod8dev/content/2334/hdoc

Это значит что, фактически, поддерживается только один уровень транзакции. То есть не существует возможности отменить действие транзакции некоторого уровня, не отменяя транзакции вышестоящего уровня.

    Менеджер транзакции содержит признак “Отменена”. Если он установлен, то транзакция считается сломанной и фактическая транзакция подлежит отмене при ее любом завершении. Устанавливается он при возникновении ошибки базы данных и при вызове ОтменитьТранзакцию(). Явно получить значение признака “Отменена” менеджера транзакции во встроенном языке нельзя. (с) Безопасная работа с транзакциями во встроенном языке
	https://infostart.ru/1c/articles/1026771/

Правильно:

НачатьТранзакцию();
Попытка
    // блокировки, чтение, запись
    // ..
    ЗафиксироватьТранзакцию();
Исключение
    ОтменитьТранзакцию();
    ВызватьИсключение; // есть внешняя транзакция
КонецПопытки

Общее правило состоит в следующем: если при выполнении транзакции имели место ошибки базы данных, то следует отменить всю транзакцию в целом и, в случае необходимости, повторить попытку ее выполнения с самого начала.

Если внутри транзакции произошла исключительная ситуация, она откатывается. Если внутри транзакции были вложенные транзакции или она сама являлась вложенной, откатываются все транзакции, независимо от того, на каком из уровней вложенности это произошло.

НАстольная книга эксперта:

Транзакции, как явные, так и неявные, могут быть вложенными. Обычный случай, например, запись элемента одного справочника из процедуры ПриЗаписи модуля другого справочника или из подписок на события, обрабатываемых внутри транзакции. Применение такого подхода при всем его удобстве, однако, может создавать проблемы производительности, поэтому пользоваться им надо аккуратно, а злоупотреблять, создавая каскады записывающихся друг из друга объектов, не стоит вообще. 

Если внутри транзакции произошла исключительная ситуация, она откатывается. Если внутри транзакции были вложенные транзакции или она сама являлась вложенной, откатываются все транзакции, независимо от того, на каком из уровней вложенности это произошло.

Проще говоря, никто не запрещает начинать одну транзакцию внутри другой, но ведет себя все это почти всегда как одна транзакция самого верхнего уровня, т. е. вложенные транзакции игнорируются. Нюансы поведения, связанные с отработкой некоторых ошибок в коде, приведены ниже.

Если исключительную ситуацию отработать с помощью скобок Попытка... Исключение... КонецПопытки, расположенных внутри транзакции, то транзакция не завершится в момент возникновения исключительной ситуации, она дойдет до
следующего обращения к данным – чтения или записи, продолжая при этом блокировать ресурсы, и откатится с сообщением: «В данной транзакции уже происходили ошибки!».

Если таких ошибок много и они начинают создавать проблемы пользователям, то без модификации кода, удаления этих скобок очень трудно найти, где они произошли и почему.

Описанное поведение системы позволяет говорить о том, что при возникновении ситуации, когда внутри транзакций нужно использовать скобки Попытка... Исключение... КонецПопытки, необходимо, отработав исключительную ситуацию, вызывать оператор ВызватьИсключение.

Случается, однако, что транзакция, встретившись с ошибкой, находящейся в скобках Попытка... Исключение... КонецПопытки, продолжает работу. Такое различие в поведении будет зависеть от типа исключительной ситуации. Исключительные ситуации бывают восстановимыми (после которых можно продолжить работу и завершить транзакцию) и невосстановимыми (после которых нельзя продолжить работу и завершить транзакцию, например, ошибка базы данных). Внешне это может выглядеть как зависимость от того, как код, вызвавший исключение, и скобки Попытка... Исключение... КонецПопытки расположены относительно ближайшей к ним транзакции.

Пример 1

НачатьТранзакцию();
    Попытка
        ЭтотОбъект.ВыполнитьНесуществующийМетод(); 
        // (такого метода у объекта не создавали)
    Исключение
        
    КонецПопытки;
 
    Запрос = Новый Запрос;
    Запрос.Текст = "ВЫБРАТЬ
    | ПлатежноеПоручение.Ссылка
    |ИЗ
    | Документ.ПлатежноеПоручение КАК ПлатежноеПоручение";
    
    Результат = Запрос.Выполнить();
    
    СпрСсылка = Справочники.Организации.НайтиПоКоду("000001");
    СпрОбъект = СпрСсылка.ПолучитьОбъект();
    СпрОбъект.НаименованиеПолное = ТекущаяДата(); 
    // это чтобы отследить, зафиксирована транзакция или нет
    СпрОбъект.Записать();
ЗафиксироватьТранзакцию();

Код выполнится. Транзакция успешно завершится. Исключительная ситуация оказалась расценена как восстановимая.

Пример 2

Сначала в процедуру ПриЗаписи модуля справочника Организации добавим строку:

ЭтотОбъект.ВыполнитьНесуществующийМетод(); 
// (такого метода у объекта не создавали)

Далее изменим код из примера 1:

НачатьТранзакцию();
    Попытка
        СпрСсылка = Справочники.Организации.НайтиПоКоду("000001");
        СпрОбъект = СпрСсылка.ПолучитьОбъект();
        СпрОбъект.НаименованиеПолное = ТекущаяДата(); 
        //это чтобы отследить, зафиксирована транзакция или нет
        СпрОбъект.Записать(); // неявная транзакция, там, как помним, ошибка
    Исключение
    
    КонецПопытки;
    Запрос = Новый Запрос;
    Запрос.Текст = "ВЫБРАТЬ
    | ПлатежноеПоручение.Ссылка
    |ИЗ
    | Документ.ПлатежноеПоручение КАК ПлатежноеПоручение";
    Результат = Запрос.Выполнить();

ЗафиксироватьТранзакцию();

Получим ошибку:

Ошибка при вызове метода контекста (Выполнить) 
Результат = Запрос.Выполнить();
По причине: Ошибка выполнения запроса. 
По причине: В данной транзакции уже происходили ошибки!

Исключительная ситуация, хотя она вызвана аналогичной строкой кода, потянула за собой дополнительные последствия (откат транзакции записи элемента справочника) и оказалась расценена как невосстановимая.

 

Дополнительные параграфы:
При использовании оператора ВызватьИсключение необходимо сохранять стек ошибок

О вложенных попытках, исключениях и о представлении ошибок
https://infostart.ru/1c/articles/1513676/

 
Объектное чтение набора записей в транзакции устанавливает неявную управляемую разделяемую блокировку

Это может вызвать взаимоблокировку в параллельных транзакциях

Какие бывают блокировки в 1С?
https://infostart.ru/1c/articles/629017/
 
Чтение данных в транзакции с их последующим изменением, необходимо производить после установки исключительной управляемой блокировки

    Ответственное чтение данных
	https://its.1c.ru/db/v8std/content/648/hdoc
 

Диагностики взяты с сайтов: 

    https://1c-syntax.github.io/bsl-language-server/diagnostics/
    https://docs.checkbsl.org/checks/ОписанияПравилПроверкиКода/

 

Для контроля ошибок рекомендую использовать:

    для vscode плагин Language 1C (BSL)
	https://marketplace.visualstudio.com/items?itemName=1c-syntax.language-1c-bsl
    для конфигуратора Phoenix BSL для 1С
	https://github.com/otymko/phoenixbsl/
    для сонара SonarQube 1C (BSL) Community Plugin
	https://github.com/1c-syntax/sonar-bsl-plugin-community
 	

Параграфы написаны в формате побудительных предложений, чтобы при код-ревью типичных ошибок работы с транзакциями копировать абзац целиком.

Статья написана в личных целях для онбординга новых сотрудников, является частью соглашений по стилю кода.



artbear 1420 01.12.22 22:08
Хорошая подборка!
Значит, мы не зря придумывали и реализовывали эти правила.

Есть замечания
>ОписаниеОшибки() и КраткоеПредставлениеОшибки() не содержат текста строки, вызвавшей ошибку. Код может измениться к моменту анализа ошибки, и придется дополнительно исследовать, где же именно возникла ошибка.

это неверно. Эти методы как раз содержат текст ошибки и строку с модулем, в котором возникла ошибка, и только.
но нет стека вызовов, а значит, непонятно, какая последовательность вызовов привела к ошибке.

именно наличие стека вызовов важно, а он есть только в ПодробноеПредставлениеОшибки, поэтому и нужно использовать данный метод. 



Разные материалы по запросам 1С
оф документация https://its.1c.ru/db/v8321doc#bookmark:dev:TI000001743
https://infostart.ru/1c/articles/204054/

// JOINS

//---- ГОРОДА
Выбрать
	1 как ИД
	,"Москва" КАК Имя
Поместить Города
Объединить все
Выбрать
	2 как ИД
	,"Лондон" КАК Имя
Объединить все
Выбрать
	3 как ИД
	,"Сингапур" КАК Имя
Объединить все
Выбрать
	4 как ИД
	,"Сидней" КАК Имя
;

//---- ОФИСЫ
Выбрать
	1 как ИД
	,1 КАК Город
	,"ОфисМосква1" КАК Имя
Поместить Офисы
Объединить все
Выбрать
	2 как ИД
	,1 КАК Город
	,"ОфисМосква2" КАК Имя
Объединить все
Выбрать
	3 как ИД
	,2 КАК Город
	,"ОфисЛондон" КАК Имя
Объединить все
Выбрать
	4 как ИД
	,5 КАК Город
	,"ОфисБангкок" КАК Имя
;

//--------------  ВЫБОРКА
Выбрать
	"Все города", *
ИЗ
	Города
;
Выбрать
	"Все офисы", *
ИЗ
	Офисы

;
//
Выбрать
	"CROSS-JOIN. Строк = 16. Декартово произведение"
    , *
ИЗ
	Города , Офисы
;
//
Выбрать
	"LEFT-JOIN по Истине, фактически аналог CROSS-JOIN. Строк = 16. Декартово произведение"
    , *
ИЗ
	Города 
	LEFT JOIN Офисы
	ON Истина
;
// 
Выбрать
	"RIGHT-JOIN по Истине, фактически аналог CROSS-JOIN. Строк = 16. Декартово произведение"
    , *
ИЗ
	Города 
	RIGHT JOIN Офисы
	ON Истина
;
// 
Выбрать
	"FULL-JOIN по Истине, фактически аналог CROSS-JOIN. Строк = 16. Декартово произведение"
    , *
ИЗ
	Города 
	FULL JOIN Офисы
	ON Истина
;

// 
Выбрать
	"LEFT-JOIN по ЛОЖЬ, Строк = 4. Все из городов, ничего из офисов"
    , *
ИЗ
	Города 
	LEFT JOIN Офисы
	ON ЛОЖЬ
;

// 
Выбрать
	"RIGHT-JOIN по ЛОЖЬ, Строк = 4. Все из офисов, ничего из городов"
    , *
ИЗ
	Города 
	RIGHT JOIN Офисы
	ON ЛОЖЬ
;

// 
Выбрать
	"FULL-JOIN по ЛОЖЬ, Строк = 8. Все из офисов, все из городов, но не пересекаются"
    , *
ИЗ
	Города 
	FULL JOIN Офисы
	ON ЛОЖЬ
;

// 
Выбрать
	"LEFT-JOIN. Строк = 5. Всё из Городов (Москва 2 раза), только совпадения из Офисов"
    , *
ИЗ
	Города 
	LEFT JOIN Офисы
	ON Офисы.Город = Города.ИД
;

// 
Выбрать
	"RIGHT-JOIN. Строк = 4. Всё из Офисов, только совпадения из Городов"
    , *
ИЗ
	Города 
	RIGHT JOIN Офисы
	ON Офисы.Город = Города.ИД
;
// FULL-JOIN. Строк = 6. Всё из Офисов, всё Городов
// для Москвы - 2 строки, т.к. 2 офиса
Выбрать
	"FULL-JOIN. Строк = 6. Всё из Офисов, всё Городов, Москва 2 раза"
    , *
ИЗ
	Города 
	FULL JOIN Офисы
	ON Офисы.Город = Города.ИД
;


---------------------------- города и офисы на MSSQL
USE master;

DROP TABLE IF EXISTS cities;
DROP TABLE IF EXISTS offices;

create table cities(
id int not null
,name nvarchar(200)
);
create table offices(
id int not null
,name nvarchar(200)
,city int
);

---- cities
insert into cities
select
	1 as id
	,'Москва' as name

union all
select
	2 as ИД
	,'Лондон' as Имя
union all
select
	3 as ИД
	,'Сингапур' as Имя
union all
select
	4 as ИД
	,'Сидней' as Имя
;

---- offices
insert into offices (id, city, name)
select
	1 as id
	,1 as city
	,'ОфисМосква1' as bane

union all
select
	2 as ИД
	,1 as Город
	,'ОфисМосква2' as Имя
union all
select
	3 as ИД
	,2 as Город
	,'ОфисЛондон' as Имя
union all
select
	4 as ИД
	,5 as Город
	,'ОфисБангкок' as Имя
;

--------------  ВЫБОРКА
select
	'Все cities', *
from
	cities
;
select
	'Все offices', *
from
	offices

;

select
	'CROSS-JOIN. Строк = 16. Декартово произведение'
    , *
from
	cities , offices
;
select
	'CROSS-JOIN. Строк = 16. Декартово произведение'
    , *
from
	cities cross join offices
;
select
	'LEFT-JOIN по Истине, фактически аналог CROSS-JOIN. Строк = 16. Декартово проfromведение'
    , *
from
	cities 
	LEFT JOIN offices
	ON 1=1
;

select
	'RIGHT-JOIN по Истине, фактически аналог CROSS-JOIN. Строк = 16. Декартово проfromведение'
    , *
from
	cities 
	RIGHT JOIN offices
	ON 1=1
;
 
select
	'FULL-JOIN по Истине, фактически аналог CROSS-JOIN. Строк = 16. Декартово проfromведение'
    , *
from
	cities 
	FULL JOIN offices
	ON 1=1
;

 
select
	'LEFT-JOIN по ЛОЖЬ, Строк = 4. Все from городов, ничего from офисов'
    , *
from
	cities 
	LEFT JOIN offices
	ON 1=0
;

 
select
	'RIGHT-JOIN по ЛОЖЬ, Строк = 4. Все from офисов, ничего from городов'
    , *
from
	cities 
	RIGHT JOIN offices
	ON 1=0
;

 
select
	'FULL-JOIN по ЛОЖЬ, Строк = 8. Все from офисов, все from городов, но не пересекаются'
    , *
from
	cities 
	FULL JOIN offices
	ON 1=0
;

 
select
	'LEFT-JOIN. Строк = 5. Всё from Городов (Москва 2 раза), только совпадения from Офисов'
    , *
from
	cities 
	LEFT JOIN offices
	ON offices.city = cities.id
;

 
select
	'RIGHT-JOIN. Строк = 4. Всё from Офисов, только совпадения from Городов, Москва 2 раза'
    , *
from
	cities 
	RIGHT JOIN offices
	ON offices.city = cities.id
;
 --FULL-JOIN. Строк = 6. Всё from Офисов, всё Городов
 --для Москвы - 2 строки, т.к. 2 офиса
select
	'FULL-JOIN. Строк = 6. Всё from Офисов, всё Городов, Москва 2 раза'
    , *
from
	cities 
	FULL JOIN offices
	ON offices.city = cities.id
;



// AGGREGATES

// SALARIES


Выбрать
	1000 как Зарплата
	,"Кассир" КАК Должность
	,"Магазин" КАК Подразделение
Поместить Компания
Объединить все
Выбрать
	2000 как Зарплата
	,"Кладовщик" КАК Должность
	,"Магазин" КАК Подразделение
Объединить все
Выбрать
	2000 как Зарплата
	,"Водитель погрузчика" КАК Должность
	,"Магазин" КАК Подразделение
Объединить все
Выбрать
	4000 как Зарплата
	,"Директор" КАК Должность
	,"Магазин" КАК Подразделение

Объединить все
Выбрать
	5000 как Зарплата
	,"Менеджер по продажам" КАК Должность
	,"Оптовый отдел" КАК Подразделение
Объединить все
Выбрать
	6000 как Зарплата
	,"Руководитель отдела" КАК Должность
	,"Оптовый отдел" КАК Подразделение
Объединить все
Выбрать
	6000 как Зарплата
	,"Программист" КАК Должность
	,"Оптовый отдел" КАК Подразделение
;
// выбрать должности с максимальной зарплатой в разрезе подразделений
// вариант через INNER JOIN. Похожим образом работает срез последних
Выбрать
	Компания.Должность,
	Компания.Подразделение,
	Компания.Зарплата
из
	Компания
	inner join
	(
		выбрать
			МАКСИМУМ(Зарплата) КАК МаксЗарплата,
			Подразделение
		
		ИЗ
			Компания
		Сгруппировать по
			Подразделение
	) КАК Подзапрос
	ПО Подзапрос.Подразделение = Компания.Подразделение
	И Компания.Зарплата = Подзапрос.МаксЗарплата
;
// вариант через вхождение в подзапрос
Выбрать
	Компания.Должность,
	Компания.Подразделение,
	Компания.Зарплата
из
	Компания
где
	(Компания.Зарплата, Компания.Подразделение) В
	(
		выбрать
			МАКСИМУМ(Зарплата) КАК МаксЗарплата,
			Подразделение
		
		ИЗ
			Компания
		Сгруппировать по
			Подразделение
	) 

в MSSQL такой фичи нет: (Компания.Зарплата, Компания.Подразделение) В
там будут ошибки
1 если выбрать 2 и более полей в подзапросе, например так:
(
		select 
			max(Зарплата) as МаксЗарплата,
			Подразделение
ошибка будет такая:
Only one expression can be specified in the select list when the subquery is not introduced with EXISTS.
2 если указать 2 поля перед оператором IN
(company.Зарплата, company.Подразделение) in
то будет ошибка
An expression of non-boolean type specified in a context where a condition is expected, near ','.

Пример с зарплатой для MSSQL 

USE master;

DROP TABLE IF EXISTS dbo.company;

Create table dbo.company (
[Зарплата] integer
,[Должность] nvarchar(250)
,[Подразделение] nvarchar(250)
);

insert into company
SELECT 
	1000 as Зарплата
	,'Кассир' as Должность
	,'Магазин' as Подразделение

union all
SELECT
	2000 as Зарплата
	,'Кладовщик' as Должность
	,'Магазин' as Подразделение
union all
SELECT
	2000 as Зарплата
	,'Водитель погрузчика' as Должность
	,'Магазин' as Подразделение
union all
SELECT
	4000 as Зарплата
	,'Директор' as Должность
	,'Магазин' as Подразделение

union all
SELECT
	5000 as Зарплата
	,'Менеджер по продажам' as Должность
	,'Оптовый отдел' as Подразделение
union all
SELECT
	6000 as Зарплата
	,'Руководитель отдела' as Должность
	,'Оптовый отдел' as Подразделение
union all
SELECT
	6000 as Зарплата
	,'Программист' as Должность
	,'Оптовый отдел' as Подразделение
;

select
	company.Должность,
	company.Подразделение,
	company.Зарплата
from
	dbo.company as company
where
	company.Зарплата in
	(
		select 
			max(Зарплата) as МаксЗарплата
		from
			company
		group by
			Подразделение
		having Подразделение = company.Подразделение
	) 


Типичная ошибка человека, следующего рекомендациям фирмы 1С:
https://infostart.ru/1c/articles/204054/
При соединении двух таблиц оптимизатор СУБД выбирает алгоритм соединения 
таблиц исходя из количества записей в обеих таблицах. В случае наличия 
вложенного запроса, определить количество записей, которое вернет вложенный 
запрос крайне сложно. Поэтому вместо вложенных запросов всегда стоит 
использовать временные таблицы.
Объяснение, почему данное утверждение неверно, дается в моей статье:
https://infostart.ru/1c/articles/880836/


Реализация группового оператора вхождения

В отличие от простого оператора вхождения, аналог которого имеется в большинстве СУБД 
(оператор IN языка SQL), групповой оператор вхождения не имеет точных аналогов в SQL. 
Поэтому при использовании группового оператора вхождения важно учитывать механизм его 
перевода в SQL. Оператор вида:

(<Выражение 1>, ..., <Выражение N>) В (
    ВЫБРАТЬ <Колонка 1>, ..., <Колонка N>
    ИЗ <Источники>
    ГДЕ <Условие>
)
при выполнении его на СУБД будет иметь вид:

Копировать в буфер обмена
EXISTS(
    SELECT 1
    FROM <Источники>
    WHERE (<Условие>) AND <Выражение 1> = <Колонка 1> AND ... AND <Выражение N> = <Колонка N>
)
Если вложенный запрос содержит агрегатные функции и/или раздел СГРУППИРОВАТЬ ПО, то групповой оператор вхождения вида:

Копировать в буфер обмена
(<Выражение 1>, ..., <Выражение N>) В (
    ВЫБРАТЬ <Колонка 1>, ..., <Колонка N>
    ИЗ <Источники>
    ГДЕ <Условие 1>
    СГРУППИРОВАТЬ ПО <Список группировки>
    ИМЕЮЩИЕ <Условие 2>
)
на языке SQL будет записан так:

Копировать в буфер обмена
EXISTS(
    SELECT 1
    FROM <Источники>
    WHERE <Условие 1>
    GROUP BY <Список группировки>
    HAVING (<Условие 2>) AND <Выражение 1> = <Колонка 1> AND ... AND <Выражение N> = <Колонка N>
)

Удаление дублей в 1С
Удаление дублей в MSSQL

USE master;

DROP TABLE IF EXISTS dbo.banks;

create table banks (
	id int not null
	, name nvarchar(200)
);
insert into banks (id, name) values (1, 'JP Morgan'),
(2, 'Deutsche bank'), (3, 'HSBC'), (4, 'Deutsche bank'),
(5, 'UBS')
;

--вариант через IN
delete from 
	banks 
where 
	id in (
			select 
				b1.id 
			from 
				banks b1
				left join banks b2
				on b2.name = b1.name
			where 
				b1.id > b2.id)
;
--вариант через EXISTS
delete b1 from banks as b1
where 
	exists (
		select 
			1 
		from 
			banks as b2 
		where 
			b2.name = b1.name 
			and b2.id < b1.id
)
--вариант через CTE и ROW_NUMBER
--https://ru.stackoverflow.com/questions/607555/%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D1%83%D0%B1%D0%BB%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D0%B2-%D1%81%D1%82%D1%80%D0%BE%D0%BA-%D0%B2-mssql
with cte as (
	select
		rn = ROW_NUMBER() over (PARTITION BY name order by name)
		--,name -- это для проверки
	from
		banks
)
delete from cte where rn > 1
--select * from cte --это для проверки
;
--вариант через group by
--select * --для проверки
delete b1
from banks as b1
inner join (
	select 
		MIN (ID) as firstID
		,name
	from
		banks 
	group by
		name
	having count(*) > 1
) as dup
ON dup.name = b1.name
WHERE b1.id > dup.firstID





Выборка "пакетами" в запросе
Задача: необходимо выбрать какой-то объем данных небольшими порциями именно в запросе.
